우리가 머신러닝 수학을 공부할 방법은 spectral teories 야.

이 말은 하나의 개념에서 시작해서, 그 개념을 잘게 부숴서 독립 개별 개념으로 이해할 거라는 거지.

딥러닝은 간단하지만 complicated, complex 한 내용이야.

complicated는 부품이 많지만, 어렵지는 않아. 단순하게 이해하고 사용할 수 있어. 직관적이야.

이와 비교해서 complex는 수는 덜 하지만, 비선형적이고, 이해하기가 어려운 내용을 의미하지.  

정리하자면,

사실 딥러닝은 매우 쉬운 수학적 개념으로 만들어졌어. 가중치를 데이터와 곱해서 더한다.라는

그러나 매우 많은 파트들의 결합으로 complicated 하고

비선형적 구조를 보면 이해할 수 없을 정도로 complex하기도 해.

---
---
(이번시간에는 머신러닝에 대한 수학적 이해를 위해 우리끼리 사용할 용어 정리를 하고 넘어가겠습니다.)

우선  ML에서 사용되는 자료구조 부터 이해하고 넘어갑시다.

완전히 정확한 개념은 아니지만 ML을 하면서 소통이 될 수만 있도록 이해하고 갈게요.

먼서 Scalar 는 단순한 숫자라고 생각하면 됩니다. 

다음으로는 Vector 는 숫자의 열 혹은 행 정도로 이해하면 되고,

Matrix는 그러한 행과 열이 합쳐져서 2차원 행렬이 될 때를 지칭할게요.

마지막으로 우리가 주로 사용할 Tensor는 3차원 이상의 배열들을 표현할 때 사용하겠습니다.

추가적으로 우리는 np.array와 torch.tensor 라는 타입을 쓸건데, 
이러한 데이터 타입의 개념을 자세히 알기보다는, 
데이터 타입이 다르면 작동되지 않을 수 있다는 사실만 기억하시고,
코드 작성시 유의해주세요. 

---

다음으로 우리가 다룰 데이터의 두 성질에 대해서 간단히 집고 넘어갑시다.

continuous와 categorical 성질이 있는데요.

continuous는 연속적인 성질, 숫자 성질이라고 이해하시면 되요. 거의 무한한 데이터를 구분할 수 있지요.

categorical은 목차가 있는 성질이라고 보시면 됩니다. 분류를 위한 데이터로 맞는지, 아닌지를 구분하는 데이터라고 생각하시면 됩니다.

그러나 ML을 하면서 문자열 데이터는 사용하기 매우 불편합니다. 그래서 categorical 데이터를 encoding해서 주로 쓰는데요.

labelencoding과 onehotencoding을 주로쓰는데 이에 대해선 실습에서 설명해드리겠습니다.

---

다음으로 전치(Transpose)에 대해서 간단히 설명해드릴게요

우리가 ML에선 데이터에 가중치를 곱해준다고 했잖아요? 근데 하나하나 곱하게 되면 너무 귀찮잖아요.

그래서 행렬의 내적(dot product)으로 한번에 곱하는 방법을 사용해요.

그런데 이 내적을 위해선 행렬의 크기가 조정이 되야 하는데요.

만약 m x n 크기의 행렬에 내적을 해주려면 n x ? 의 행렬만 곱할 수 있어요.

그래서 m x n 행렬에 m x n 행렬을 곱하려면 n x m 으로 형태를 바꿔줘야 하는데 

그 방법이 전치 입니다.

단순히 행과 열만 바꿔주면 되요.

그리고 우리는 전치 transpose의 앞 글자를 따서 T 를 붙여서 표시하겠습니다.

```python
# numpy
import numpy as np

np.array.T
np.transpose()

# pytorch
torch.tensor.T

```

그래서 다음으로 dot product 가 어디에 쓰이는지 확인하자면

ann 에선 이전에 말했듯이 가중치 벡터와 데이터 벡터를 곱해서 하나의 스칼라 값을 낼 수 있습니다.

그리고 이후 이미지 분류에 사용되는 CNN 에서 Convolution 이라는 개념이 나오는데,

그 때 우리의 2차원 데이터와 convoulution layer의 filter로 값을 내적해줘서,

복잡한 이미지 데이터에서 특징 데이터를 추출할 수 있습니다.

수학적으로 보자면 두 값 사의의 상관관계를 숫자로 표현했다고 이해하면 될 거 같습니다.

```python
# numpy
np.dot(nv1, nv2)
# np.sum(nv1 * nv2) 와 결과가 같아

# pytorch
torch.dot(tv1, tv2)
torch.sum(tv1 * tv2)
```
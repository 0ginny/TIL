#### 1205 구현

모든 경우의 수를 찾는 것이 어려웠음.

시작하기 전에 모든 경우의 수를 다 생각해보자

if elif 로만 구성해서 case 분류 안되는 상황이 뭔지 파악하자

구현을 사람이 생각하는 것처럼 순차적으로 하는 것보다, 연산을 단축시키는 방식이 더 쉬울 수 있어.

#### 1244 구현

문제의 입력과 출력은 반드시 정확히 숙지하자

#### 17266 시간복잡도에 대해서 
```python
def solution():
    n = int(input())
    _ = int(input())
    lights = list(map(int, input().split()))
    prev = 0
    height = 1
    while lights[0] - height > 0:
        height += 1
    for light in lights:
        while light - height > prev:
            height += 1
            prev += 1
        prev = light + height
    while lights[-1] + height < n:
        height += 1
    print(height)


solution()
```

이런식으로 구하면 for문이 여러개 인데도 시간복잡도 미만이야.

증가해야할 변수가 있으면 처음부터 가지 말고 이전 결과값을 저장해서 증가하는 형식으로도 구현해보자.

```python
# 이런식으로 올림을 구현할 수도 있네.
d = (li[i+1]-li[i]+1)//2
```

#### 20920 defaultdict

[참고자료](https://www.daleseo.com/python-collections-defaultdict/)

나는 try except 로 구현했는데 defaultdict 로 구현 가능해.

#### 1927 heap

[python 에서 heap 사용](https://littlefoxdiary.tistory.com/3)

[heap 자료구조 시간복잡도](https://mjmjmj98.tistory.com/154)

#### 11501 그리디

그리디 문제에서는 보통 뒤에서 부터 봤을 때 풀리는 경우가 종종 있는 거 같아.

아무 상관 없어보여도 뒤에서 부터 리스트를 뽑았을 때 상황도 계속 고려해보자

#### 1406 연결리스트

두 리스트가 연결되어 있어서 한쪽에서 빠진게 다른쪽에 연결되는 것.

#### 2747 DP

DP는 굳이 재귀로 풀기보다 리스트로 만들어서 푸는게 더 나아

#### 1463 DP

DP 는 점화식이야. 그러니까 작은 값부터 계산 한 것이 다음 값에 영향을 주는 경우라고 생각해

그럼 접근을 n = 1 부터 시작해야하지.

그리고 조건문이 있으면, 조건문을 적용하는 순서도 중요해

#### 11727 DP

DP인건 알았는데,, 규칙이 생각이 안되었어. 뭐가 문제였을까??

일단 dp는 이전 단계에 대한 연관성을 찾고, 완료되지 않으면 그 다음 단계에 대한 연관성을 찾는 반복을 해야하는 거 같아.